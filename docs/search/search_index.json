{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Git Tutorial for non-programmers","text":"<p>Git is a free and open source distributed version control system designed to  handle everything from small to very large projects with speed and efficiency.  It is the most popular version control system among professional programmers,  and this tutorial aims to making it understandable and usable by non-programmers.</p> <p>Git can be used both from the command-line interface (a.k.a. <code>cmd</code> under windows) or via a graphical user interface. This page describes the operations that Git can execute, independently from the type of interface and refers to other pages for  the CLI way of doing it. This resource does not explain how to use any of the several available GUI's, but you can find  the documentation you need on the internet once you know the basics. </p>"},{"location":"#lets-get-started-init","title":"Let's get started: <code>init</code>","text":"<p>Say that you have a folder <code>MyProject</code> containing some files (or empty) and you want to start  version-controlling it with git. To do that you ask git to run the <code>init</code> operation.</p> <p>The <code>git init</code> operation creates a <code>.git</code> subfolder inside the <code>MyProject</code> folder, which will hold all the git internal files. You don't need to be concerned about that folder; just don't delet it, or git will lost all its memory about the version history of <code>MyProject</code>.</p> <p>Learn how to perform the <code>git init</code> operation via the CLI.</p>"},{"location":"#save-your-work-commit","title":"Save your work: <code>commit</code>","text":"<p>We all make backups of our work so now and then: we take the folder containig our work and we make a copy of it, namining it something like <code>MyProject_2024-10-14</code>. So, if anything goes wrong with the files in our working directory <code>MyProject</code>, we can always restore an older version of it.</p> <p>In git terms, this is a commit operation (to commit = consign or record for preservation). You run a <code>git commit</code> operation and git will make a copy of your working directory and give it a name for you. You can commit as many versions of your working directory as you want.</p> <p>Notice that git commit takes a snapshot of your entire working directory, but it does it in a smart and disk-space-efficient way: just the minimum amount of information strictly necessary will be stored on disk.</p> <p>We will visually represnt the working directory (WD) and its commits (git name for snapshot/backup)  as shown in the following picture.</p> <p></p> <p>Learn how to perform the <code>git commit</code> operation via the CLI.</p>"},{"location":"#restore-your-work-checkout","title":"Restore your work: <code>checkout</code>","text":"<p>If you want to restore the working directory to the status it had at the moment of a certain commit, you run the <code>git checkout</code> operation.</p> <p></p> <p>Learn how to perform the <code>git checkout</code> operation via the CLI.</p>"},{"location":"#try-new-ideas-branch","title":"Try new ideas: <code>branch</code>","text":"<p>There are situations when you may want to create a copy (WD2) of your working directory (WD1), try something new without messing up the original copy WD1 and  eventually, if your new idea works, delete the original WD1 and go back to having  only one version (WD2) of your work. If your new idea turns out to be a bad idea,  you can just delete the second copy WD2 of your working directory and go back to  the original copy WD1.</p> <p>The operation of creating a copy of your working directory, in Git is called <code>branching</code>; except that Git doesn't really create a copy of anything: the branch exists in the <code>.git</code> folder and you just choose which branch gets loaded in your working directory.</p> <p>Say that you have done 3 commits and that your working directory corresponds to the third commit. In git terms, you are on the <code>main branch</code> and the status of your project looks like the following figure.</p> <p></p> <p>When you create a new branch (say branch 'bravo'), it's like if a copy of  commit 03 is made internally by git.</p> <p></p> <p>Now you can switch to the branch 'bravo' and start committing changes to that branch, while the 'main' branch stays unchanged.</p> <p></p> <p>You can switch between your two branches as many times as you want. Every time you switch branch, the latest commit of that branch will be checked-out to your working directory. If you switch back to the 'main' branch, you can also keep committing changes to it.</p> <p></p> <p>Learn how to perform the <code>git branch</code> operation via the CLI.</p>"},{"location":"#synchronize-branches-merge","title":"Synchronize branches: <code>merge</code>","text":"<p>In the previous section we talked about the <code>git banch</code> operation, which is conceptually equivalent to making a copy (a branch) of your working directory and having two versions of the same project. Let's imagine that we have  modified both copies of the project forlder (committed changes in both branches).  In such a situation, going back to one version that keeps all the changes made  to both branches, can be a real pain. Git makes it easy, by implementing  the <code>merge</code> command.</p> <p>The <code>git merge</code> command takes the last commits of two different branches and mixes  them together in a new commit, so that the new commit contains all the changes of both  the branches. The following figure shows merging the branch 'bravo' (commit 05) and  the branch 'main' (commit 07) into the new commit 08, which is then added to the 'main' branch.</p> <p></p> <p>Learn how to perform the <code>git merge</code> operation via the CLI.</p>"},{"location":"#collaboration-clone-push-and-pull","title":"Collaboration: <code>clone</code>, <code>push</code> and <code>pull</code>","text":"<p>Say that Remy, a colleagues of yours, has a Git-versioned project for which he needs  your help and say that you do want to cooperate with him on his project. One way for Remy to allow you to do so is by giving you access to his project folder  and let you modify its content. A better way is to give you a copy of his project folder, let you modify your own copy of the files and then merge the two copies again.</p> <p>In the Git world, the operation of getting a copy of someone else's project folder from his computer to yours is called 'cloning'.</p> <p></p> <p>When you have committed some changes to your local clone of Remy's project folder,  you may want to send those commits over to Remy's machine, so he stays in sync. This operation is called <code>push</code>: you push your changes to Remy's project folder.</p> <p></p> <p>When Remy has committed some changes to his local project folder, you may want to fetch those commits from his machine to keep your clone in sync. This operation is called <code>pull</code>: you pull Remy's changes from his project folder.</p> <p></p> <p>In reality, pull will not just fetch the remote commits to the local repository, but it will also merge them. There is actually a git operation that fetches  remote commits without merging them, and it is called (gess what) <code>git fetch</code>.</p> <p>Of course collaboration is not limited to a two-people team: you can collaborate with as many people as you want. Each collaborator holds his/her own version of the project on his/her local machine and anybody can push to or pull from  anybody else.</p> <p>Of course collaborating on large projects requires a minimum of coordination between the team members and the definition of a set of collaboration rules.  Git doesn't dictate any of those rules and leaves the team members completely  free to choose their cooperation strategy. </p> <p>Over time, two main git branching strategies for collaboration have emerged: Git Flow and  trunk-based development. You can learn about them via the provided links or one of the many resources available on the internet.</p>"},{"location":"#what-is-github-then","title":"What is GitHub then?","text":"<p>In the previous chapter we have stated that Remy can share his project folder  over the network and give permission to other people to clone his folder and push or pull changes to and from it. But whe haven't shown how Remy can  actually to do that! That's because it's not a very straightforward operation  for beginners (to who this articol is addressed). </p> <p>Luckily GitHub (and many  other similar services) come to the rescue, by providing an easy way (web-based interface) to create  (and host) remote repositories and share them with others.</p> <p>Therefore GitHub and its competitors are just web-services based on Git.</p>"},{"location":"#learn-more","title":"Learn more","text":"<p>There are a ton of free resources available on the internet for learning Git. Here is a selection of them.</p> <ul> <li>Pro Git Book a complete (and free) book    about Git.</li> <li>Learn Git branching an interactive resource   for learning Git.</li> <li>Linus Torvalds &amp; git a video of   Linus Torvald (the creator of Linux and Git) talking about Git at Google. If   you are a nerd like me, you'll find this also very entertaining.</li> </ul>"},{"location":"about/","title":"About this tutorial","text":"<p>The Git Tutorial for non-programmers has been created within the Bolt and Beoutiful  GROW project by KCI.</p>"},{"location":"cli/","title":"Use Git via the Command-Line interface","text":"<p>This page will show how to perform the main git operations using the git Command-Line Interface (CLI) and it will do so by walking the reader through the creation of a text-based contact book, where every contact item is a text file.</p> <ul> <li>For a general description of what each Git command does,    see this article insted.</li> <li>If you don't have the git CLI installed on your machine yet, you    can download it from the git website.</li> <li>This article will assume that you operate on Microsoft Windows, but the git   commands are exactly the same on other platforms.</li> </ul>"},{"location":"cli/#git-init-operation","title":"git init operation","text":"<p>For a general description of this git operation see the main article.</p> <p>To initialize a new git repository with the git CLI, from the command-line shell, first create a new project directory; we will call our project <code>contacts</code>. </p> <p></p> <p>From within the <code>contacts</code> folder, run the <code>git init</code> command. </p> <p>This command creates a <code>.git</code> sub-directory in the <code>contacts</code> directory.</p>"},{"location":"cli/#git-commit-operation","title":"git commit operation","text":"<p>For a general description of this git operation see the main article.</p> <p>In order to have some changes to commit, let's add the firt two items to our contacts book by creating two files <code>John.txt</code> and <code>Marie.txt</code>.</p> <p>Let's write the following content to <code>John.txt</code> and save it:</p> <pre><code>name: John Nash\nphone: +1 617 253 1000\n</code></pre> <p>Let's write the following content to <code>Marie.txt</code> and save it:</p> <pre><code>name: Marie Kurie\nphone: +33 1 56 24 55 00\n</code></pre> <p>You can visualize the current changes by using the <code>git status</code> command.</p> <p></p> <p>Git has correctly detected that, compared to the initial status (empty directory) there are two new files. </p> <p>Say that this is a version of our project that we want to commit; first  of all we need to tell git which changes we want to commit and which not:  for example you may want to commit only <code>Marie.txt</code> or only <code>John.txt</code>. You do that by adding the changes you want to commit to a virtual bucket named staging area, using the <code>git add</code> command. In this case we will add all the changes to the staging area.</p> <p></p> <p>If we run the <code>git status</code> command again, we see that the status has changed: the two files are not in the Untracked status anymore, but they are now under Changes to be commited.</p> <p></p> <p>Now we can finally commit the changes and we do it using the <code>git commit</code> command, followed by a message that describes the commit.</p> <p></p> <p>If you run the <code>git status</code> command again, git will tell you that there have been made no changes since the last commit.</p> <p></p> <p>You can repeat this as many times as you want. To ilustrate that, let's  apply some changes and commit them. </p> <p>First of all we mispelled the family name of Marie, therefore we need  to change the K to a C. Let's do it and save the file.</p> <pre><code>name: Marie Curie\nphone: +33 1 56 24 55 00\n</code></pre> <p>Then let's add the new item <code>Alan.txt</code> to our contacts book and set its content as follows:</p> <pre><code>name: Alan Turing\nphone: +44 20 3862 3352\n</code></pre> <p>After modifying <code>Marie.txt</code> and adding <code>Alan.txt</code> to our project,  the status will be as follows:</p> <p></p> <p>Again git has detected the changes correctly: 1 file added and 1 file changed! Let's just stage and commit these changes.</p> <p></p> <p>If you want to list all the commits stored so far, you can do so by entering the <code>git log</code> command.</p> <p></p> <p>As you can see, git has automatically assigned a unique name to each of the two commits:</p> <ul> <li>The first commit is called <code>9b457e6394b1a3918d030a703cf25b5cc81e31a4</code></li> <li>The second commit is called <code>dd8653b267c8574d592def438ce2f8195fc625ad</code></li> </ul>"},{"location":"cli/#git-checkout-operation","title":"git checkout operation","text":"<p>For a description of this operation see the main tutorial.</p> <p>So far we have initialized a git project and commited two sets of  changes. Our project folder is now identical to the second commit. If you want to go back to the first commit, you can use the <code>git checkout</code> command. In the following example, the first commit (the one named <code>9b457e6394b1a3918d030a703cf25b5cc81e31a4</code>) is checked out; notice that you need to pass only the fist few characters of the commit name: just enough to uniquely identify the commit.</p> <p></p> <p>You can now verify that, after this command, the content of the folder has been modified to match the content at the moment of the first commit, which is:</p> <ul> <li>Only two files present: <code>Marie.txt</code> and <code>John.txt</code></li> <li>The file <code>Marie.txt</code> contains the mispelled name 'Kourie'</li> </ul> <p>Although possible, this way of switching between commits is not commonly used (as the long info message suggests); branching is a much better way of doing that. Let's therefore restore the original sistuation by checkking out the master branch.</p> <p></p> <p>Again, you can now verify that the lates working directory content has  been restored. In particular:</p> <ul> <li>The folder contains three files: <code>Marie.txt</code>, <code>John.txt</code> and <code>Alan.txt</code></li> <li>The file <code>Marie.txt</code> contains the correctly spelled name 'Courie'</li> </ul> <pre><code>name: Marie Kurie\nphone: +33 1 56 24 55 00\n</code></pre>"},{"location":"cli/#git-branch-operations","title":"git branch operations","text":"<p>For a description of this operation see the main tutorial.</p> <p>Say that you decide to convert your items format from plain text to JSON but while you are busy with it you want to keep your current format available. You then need to branch your project, using the <code>git branch</code> command. We will call the new branch \"json\".</p> <p></p> <p>Now the new <code>json</code> branch has been created; you can see the list of extisting branches by typing the <code>git branch</code> command without parameters.</p> <p></p> <p>The previous command shows that there are two branches and that the active branch (the one with a * next to it) is <code>master</code>. The branch command, indeed, creates a new branch but it doesn't automatically activate it. To switch to the <code>json</code> branch, we use the <code>git checkout</code> command:</p> <p></p> <p>Notice that the screenshot of this tutorial are not made using the default windows shell (cmd), but using a git-aware shell.  That's why you see, for example, the name of the current branch next to the prompt.</p> <p>Now the active branch is <code>json</code>, but since we have just created it, its content is identical to the <code>master</code> branch. Let's then start committing changes, knowing that the original <code>master</code> branch  content is just a <code>git checkout master</code> away.</p> <p>Let's rename <code>Marie.txt</code> to <code>Marie.json</code> and modify its content as follows ...</p> <pre><code>{\n    \"name\"  : \"Marie Curie\", \n    \"phone\" : \"+33 1 56 24 55 00\"\n}\n</code></pre> <p>... and let's then save and commit the change.</p> <p></p> <p>Let's now rename <code>John.txt</code> to <code>John.json</code> and modify its content as follows ...</p> <pre><code>{\n    \"name\"  : \"John Nash\", \n    \"phone\" : \"+1 617 253 1000\"\n}\n</code></pre> <p>... and let's then save and commit the change.</p> <p></p> <p>Let's finally rename <code>Alan.txt</code> to <code>Alan.json</code> and modify its content as follows ...</p> <pre><code>{\n    \"name\"  : \"Alan Turing\", \n    \"phone\" : \"+44 20 3862 3352\"\n}\n</code></pre> <p>... and let's then save and commit the change.</p> <p></p> <p>We have now performed 5 commits in total: the first two in <code>master</code> and three in <code>json</code>, as shown by the <code>git log</code> command.</p> <p></p> <p>We could now restore the <code>master</code> branch using the command <code>git checkout master</code>.</p> <p></p> <p>Of course we can also go back to the <code>json</code> branch using the <code>git checkout json</code>, but first let's modify the master branch: let's create the following <code>Enrico.txt</code> file and save it.</p> <pre><code>name: Enrico Fermi\nphone: +39 06 4550 2901\n</code></pre> <p>Let's then commit the changes; notice that the changes will be always committed  to the current (master, in this case) branch.</p> <p></p> <p>Let's now log the commits (with some extra options to show the branch tree structure).</p> <p></p> <p>As you can see, the latest commit (add Enrico) belongs to the master branch. You can verify that by switching back to the json branch and checking that <code>Enrico.txt</code> is not presente in that branch.</p> <p></p>"},{"location":"cli/#git-merge-operation","title":"git merge operation","text":"<p>For a description of this operation see the main tutorial.</p> <p>In the previous chapters we have created a git-versioned project and committed some changes in different branches. Now we have two divergent branches and in this chapter we will merge them together in the master branch again.</p> <p>To merge the <code>json</code> branch into the <code>master</code> branch, we need to switch to <code>master</code> and launch the git command <code>git merge json</code>.</p> <p></p> <p>You can verify that in the working directory there are now all the changes performed in the <code>json</code> branch and all the changes performed in the <code>master</code> branch. By logging the commits tree, you can also see that the merge command has automatically created a new commit.</p> <p></p> <p>Once you are done with the <code>json</code> branch, you may delete it using the command <code>git branch -d json</code></p>"}]}